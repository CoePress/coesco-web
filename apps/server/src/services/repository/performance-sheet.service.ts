// This file was generated by generate-services.ts on 2025-09-02 08:45:51
import { PerformanceSheet } from "@prisma/client";
import { BaseService } from "./_base.service";
import { prisma } from "@/utils/prisma";
import { BadRequestError } from "@/middleware/error.middleware";
import { getEmployeeContext } from "@/utils/context";
import { execSync } from "child_process";
import path from "path";
import { transformDataForCalculationEngine } from "@/utils/data-transformer";

type PerformanceSheetAttributes = Omit<PerformanceSheet, "id" | "createdAt" | "updatedAt">;

export class PerformanceSheetService extends BaseService<PerformanceSheet> {
	protected model = prisma.performanceSheet;
	protected entityName = "PerformanceSheet";
	protected modelName = "performanceSheet";

	protected async validate(entity: PerformanceSheetAttributes): Promise<void> {
		if (!entity.versionId) throw new BadRequestError("versionId is required");
		if (!entity.data) throw new BadRequestError("data is required");
		if (!entity.createdById) throw new BadRequestError("createdById is required");
		if (!entity.updatedById) throw new BadRequestError("updatedById is required");
	}

	// Override update method to handle data-only updates and trigger calculations
	async update(id: string, data: any, tx?: any) {
		// For performance sheet updates, we typically only update the data field
		// All other required fields should be preserved from the existing record
		if (data.data && Object.keys(data).length === 1) {
			// Only updating the data field, use a simple update
			const ctx = getEmployeeContext();

			const execute = async (client: any) => {
				const model = client.performanceSheet;

				// Trigger Python calculations first
				try {
					const calculatedResults = await this.runCalculations(data.data);

					// Update with the merged calculated results
					const finalUpdated = await model.update({
						where: { id },
						data: {
							data: calculatedResults, // calculatedResults is already the complete merged structure
							updatedById: ctx.id,
							updatedAt: new Date()
						}
					});

					return finalUpdated;
				} catch (calculationError) {
					console.error('Calculation error:', calculationError);
					// Fallback: save original data without calculations
					const updated = await model.update({
						where: { id },
						data: {
							data: data.data,
							updatedById: ctx.id,
							updatedAt: new Date()
						}
					});
					return updated;
				}
			};

			const result = tx ? await execute(tx) : await prisma.$transaction(execute);

			// Return just the data field which contains the calculated performance data
			return result.data;
		} else {
			// Full update, use the base method
			return super.update(id, data, tx);
		}
	}

	// Override delete to cascade delete associated links and version
	async delete(id: string, tx?: any) {
		console.log('üóëÔ∏è Deleting performance sheet:', id);

		// Use a transaction to ensure atomicity
		const execute = async (client: any) => {
			// First, get the sheet to find its versionId
			const sheet = await client.performanceSheet.findUnique({
				where: { id },
				select: { versionId: true, deletedAt: true }
			});

			console.log('üìã Found sheet:', sheet);

			if (!sheet) {
				console.error('‚ùå Sheet not found:', id);
				throw new Error(`PerformanceSheet ${id} not found`);
			}

			if (sheet.deletedAt) {
				console.warn('‚ö†Ô∏è Sheet already deleted:', id);
				return { success: true, message: 'Sheet already deleted' };
			}

			// Delete all associated PerformanceSheetLink records (soft delete)
			console.log('üîó Deleting associated links...');
			const linksResult = await client.performanceSheetLink.updateMany({
				where: { performanceSheetId: id },
				data: { deletedAt: new Date() }
			});
			console.log(`‚úÖ Deleted ${linksResult.count} links`);

			// Delete the PerformanceSheet itself (soft delete)
			console.log('üìÑ Soft deleting sheet...');
			await client.performanceSheet.update({
				where: { id },
				data: { deletedAt: new Date() }
			});
			console.log('‚úÖ Sheet soft deleted');

			// Check if any other non-deleted sheets are using this version
			const otherSheetsUsingVersion = await client.performanceSheet.count({
				where: {
					versionId: sheet.versionId,
					deletedAt: null,
					id: { not: id }
				}
			});

			console.log(`üìä Other sheets using version: ${otherSheetsUsingVersion}`);

			// If no other sheets are using this version, soft delete it
			if (otherSheetsUsingVersion === 0) {
				console.log('üóÇÔ∏è Deleting version (no other sheets using it)...');
				await client.performanceSheetVersion.update({
					where: { id: sheet.versionId },
					data: { deletedAt: new Date() }
				});
				console.log('‚úÖ Version deleted');
			} else {
				console.log('‚ÑπÔ∏è Version kept (still in use by other sheets)');
			}
		};
		if (tx) {
			await execute(tx);
		} else {
			await prisma.$transaction(execute);
		}
		console.log('‚úÖ Delete transaction completed successfully');
		return { success: true };
	}

	private async runCalculations(inputData: any): Promise<any> {
		try {
			// Transform data for Python calculation engine (convert strings to numbers)
			const transformedData = transformDataForCalculationEngine(inputData);

			// Fix field name mismatches before sending to Python
			if (transformedData.common?.equipment?.feed) {
				// Copy lineType to typeOfLine if typeOfLine is empty
				if (transformedData.common.equipment.feed.lineType && !transformedData.common.equipment.feed.typeOfLine) {
					transformedData.common.equipment.feed.typeOfLine = transformedData.common.equipment.feed.lineType;
				}
			}

			const scriptPath = path.join(process.cwd(), 'src', 'scripts', 'performance-sheet', 'main.py');
			const inputJson = JSON.stringify(transformedData);

			// Execute the Python script by writing JSON to stdin
			const result = execSync(`python "${scriptPath}"`, {
				input: inputJson,
				encoding: 'utf-8',
				cwd: path.join(process.cwd(), 'src', 'scripts', 'performance-sheet'),
				timeout: 30000 // 30 second timeout
			});

			// Parse the JSON output from the Python script
			const calculatedResults = JSON.parse(result);

			// DIRECTLY UPDATE the original data - NO nested structures!

			// The goal: inputData should be modified in-place with calculated values
			// Python returns: { rfq: { average: 16, min: 41.67, max: 160 }, material_specs: {...}, etc. }
			// We update: inputData.common.feedRates.average.fpm = 16, etc.

			// 1. RFQ calculations ‚Üí DIRECTLY update common.feedRates section
			if (calculatedResults.rfq && inputData.common?.feedRates) {
				const rfqCalc = calculatedResults.rfq;

				// Python returns FPM calculations as: { average: 16, min: 41.67, max: 160 }
				// DIRECTLY update the original structure
				if (rfqCalc.average !== undefined && inputData.common.feedRates.average) {
					inputData.common.feedRates.average.fpm = rfqCalc.average;
				}
				if (rfqCalc.min !== undefined && inputData.common.feedRates.min) {
					inputData.common.feedRates.min.fpm = rfqCalc.min;
				}
				if (rfqCalc.max !== undefined && inputData.common.feedRates.max) {
					inputData.common.feedRates.max.fpm = rfqCalc.max;
					inputData.common.material.reqMaxFPM = rfqCalc.max;
				}
			}

			// 2. Material specs calculations ‚Üí DIRECTLY update materialSpecs.material section AND common.material
			if (calculatedResults.material_specs && inputData.materialSpecs?.material) {
				const matCalc = calculatedResults.material_specs;
				const matData = inputData.materialSpecs.material;

				// Python returns: { min_bend_radius: 90.625, min_loop_length: 30.2083, coil_od_calculated: 65, material_density: 0.283 }
				if (matCalc.min_bend_radius !== undefined) {
					matData.minBendRadius = matCalc.min_bend_radius;
				}
				if (matCalc.min_loop_length !== undefined) {
					matData.minLoopLength = matCalc.min_loop_length;
				}
				if (matCalc.coil_od_calculated !== undefined) {
					matData.calculatedCoilOD = matCalc.coil_od_calculated;
				}

				// Also update common.material if it exists
				if (matCalc.material_density !== undefined && inputData.common?.material) {
					inputData.common.material.materialDensity = matCalc.material_density;
				}
			}

			// 3. TDDBHD calculations ‚Üí tddbhd section AND common.coil for coil-related calcs
			if (calculatedResults.tddbhd && inputData.tddbhd && typeof calculatedResults.tddbhd === 'object') {
				const tddbhdCalc = calculatedResults.tddbhd;

				// Map coil calculations to both tddbhd.coil AND common.coil
				if (tddbhdCalc.calculated_coil_weight !== undefined) {
					if (inputData.tddbhd.coil) {
						inputData.tddbhd.coil.coilWeight = tddbhdCalc.calculated_coil_weight;
					}
					// Also update common.coil
					if (inputData.common?.coil) {
						inputData.common.coil.maxCoilWeight = tddbhdCalc.calculated_coil_weight;
					}
					// Also update common.material.coilWeight
					if (inputData.common?.material) {
						inputData.common.material.coilWeight = tddbhdCalc.calculated_coil_weight;
					}
				}
				if (tddbhdCalc.coil_od !== undefined) {
					if (inputData.tddbhd.coil) {
						inputData.tddbhd.coil.coilOD = tddbhdCalc.coil_od;
					}
					// Also update common.coil
					if (inputData.common?.coil) {
						inputData.common.coil.maxCoilOD = tddbhdCalc.coil_od;
					}
				}

				// Map reel calculations
				if (inputData.tddbhd.reel) {
					if (tddbhdCalc.min_material_width !== undefined) {
						inputData.tddbhd.reel.minMaterialWidth = tddbhdCalc.min_material_width;
					}
					if (tddbhdCalc.disp_reel_mtr !== undefined) {
						inputData.tddbhd.reel.dispReelMtr = tddbhdCalc.disp_reel_mtr;
					}
					if (tddbhdCalc.cylinder_bore !== undefined) {
						inputData.tddbhd.reel.cylinderBore = tddbhdCalc.cylinder_bore;
					}
					if (tddbhdCalc.friction !== undefined) {
						inputData.tddbhd.reel.coefficientOfFriction = tddbhdCalc.friction;
					}
					if (tddbhdCalc.web_tension_psi !== undefined && inputData.tddbhd.reel.webTension) {
						inputData.tddbhd.reel.webTension.psi = tddbhdCalc.web_tension_psi;
					}
					if (tddbhdCalc.web_tension_lbs !== undefined && inputData.tddbhd.reel.webTension) {
						inputData.tddbhd.reel.webTension.lbs = tddbhdCalc.web_tension_lbs;
					}
					if (tddbhdCalc.torque_required !== undefined && inputData.tddbhd.reel.torque) {
						inputData.tddbhd.reel.torque.required = tddbhdCalc.torque_required;
					}
					if (tddbhdCalc.torque_at_mandrel !== undefined && inputData.tddbhd.reel.torque) {
						inputData.tddbhd.reel.torque.atMandrel = tddbhdCalc.torque_at_mandrel;
					}
					if (tddbhdCalc.rewind_torque !== undefined && inputData.tddbhd.reel.torque) {
						inputData.tddbhd.reel.torque.rewindRequired = tddbhdCalc.rewind_torque;
					}
					if (tddbhdCalc.hold_down_force_required !== undefined && inputData.tddbhd.reel.holddown?.force) {
						inputData.tddbhd.reel.holddown.force.required = tddbhdCalc.hold_down_force_required;
					}
					if (tddbhdCalc.hold_down_force_available !== undefined && inputData.tddbhd.reel.holddown?.force) {
						inputData.tddbhd.reel.holddown.force.available = tddbhdCalc.hold_down_force_available;
					}
					if (tddbhdCalc.failsafe_holding_force !== undefined && inputData.tddbhd.reel.dragBrake) {
						inputData.tddbhd.reel.dragBrake.holdingForce = tddbhdCalc.failsafe_holding_force;
					}
					if (tddbhdCalc.failsafe_required !== undefined && inputData.tddbhd.reel.dragBrake) {
						inputData.tddbhd.reel.dragBrake.psiAirRequired = tddbhdCalc.failsafe_required;
					}

					// Map check results
					if (inputData.tddbhd.reel.checks) {
						if (tddbhdCalc.min_material_width_check !== undefined) {
							inputData.tddbhd.reel.checks.minMaterialWidthCheck = tddbhdCalc.min_material_width_check;
						}
						if (tddbhdCalc.air_pressure_check !== undefined) {
							inputData.tddbhd.reel.checks.airPressureCheck = tddbhdCalc.air_pressure_check;
						}
						if (tddbhdCalc.rewind_torque_check !== undefined) {
							inputData.tddbhd.reel.checks.rewindTorqueCheck = tddbhdCalc.rewind_torque_check;
						}
						if (tddbhdCalc.hold_down_force_check !== undefined) {
							inputData.tddbhd.reel.checks.holdDownForceCheck = tddbhdCalc.hold_down_force_check;
						}
						if (tddbhdCalc.brake_press_check !== undefined) {
							inputData.tddbhd.reel.checks.brakePressCheck = tddbhdCalc.brake_press_check;
						}
						if (tddbhdCalc.torque_required_check !== undefined) {
							inputData.tddbhd.reel.checks.torqueRequiredCheck = tddbhdCalc.torque_required_check;
						}
						if (tddbhdCalc.tddbhd_check !== undefined) {
							inputData.tddbhd.reel.checks.tddbhdCheck = tddbhdCalc.tddbhd_check;
						}
					}
				}
			}

			// 4. Reel Drive calculations ‚Üí reelDrive section AND common.equipment.reel
			if (calculatedResults.reel_drive && inputData.reelDrive && typeof calculatedResults.reel_drive === 'object') {
				const reelCalc = calculatedResults.reel_drive;

				// Map according to ReelDriveData interface
				if (inputData.reelDrive.reel) {
					if (reelCalc.reel?.size !== undefined) inputData.reelDrive.reel.size = reelCalc.reel.size;
					if (reelCalc.reel?.max_width !== undefined) inputData.reelDrive.reel.maxWidth = reelCalc.reel.max_width;
					if (reelCalc.reel?.brg_dist !== undefined && inputData.reelDrive.reel.bearing) {
						inputData.reelDrive.reel.bearing.distance = reelCalc.reel.brg_dist;
					}
					if (reelCalc.reel?.f_brg_dia !== undefined && inputData.reelDrive.reel.bearing?.diameter) {
						inputData.reelDrive.reel.bearing.diameter.front = reelCalc.reel.f_brg_dia;
					}
					if (reelCalc.reel?.r_brg_dia !== undefined && inputData.reelDrive.reel.bearing?.diameter) {
						inputData.reelDrive.reel.bearing.diameter.rear = reelCalc.reel.r_brg_dia;
					}

					// Map mandrel data
					if (reelCalc.mandrel && inputData.reelDrive.reel.mandrel) {
						Object.assign(inputData.reelDrive.reel.mandrel, {
							diameter: reelCalc.mandrel.diameter,
							length: reelCalc.mandrel.length,
							maxRPM: reelCalc.mandrel.max_rpm,
							RpmFull: reelCalc.mandrel.rpm_full,
							weight: reelCalc.mandrel.weight,
							inertia: reelCalc.mandrel.inertia,
							reflInertia: reelCalc.mandrel.refl_inert
						});
					}

					// Map backplate data
					if (reelCalc.backplate && inputData.reelDrive.reel.backplate) {
						Object.assign(inputData.reelDrive.reel.backplate, {
							diameter: reelCalc.backplate.diameter,
							thickness: reelCalc.backplate.thickness,
							weight: reelCalc.backplate.weight,
							inertia: reelCalc.backplate.inertia,
							reflInertia: reelCalc.backplate.refl_inert
						});
					}

					// Map reducer data
					if (reelCalc.reducer && inputData.reelDrive.reel.reducer) {
						Object.assign(inputData.reelDrive.reel.reducer, {
							ratio: reelCalc.reducer.ratio,
							driving: reelCalc.reducer.driving,
							backdriving: reelCalc.reducer.backdriving,
							inertia: reelCalc.reducer.inertia,
							reflInertia: reelCalc.reducer.refl_inert
						});
					}

					// Map chain data
					if (reelCalc.chain && inputData.reelDrive.reel.chain) {
						Object.assign(inputData.reelDrive.reel.chain, {
							ratio: reelCalc.chain.ratio,
							sprktOD: reelCalc.chain.sprkt_od,
							sprktThickness: reelCalc.chain.sprkt_thk,
							weight: reelCalc.chain.weight,
							inertia: reelCalc.chain.inertia,
							reflInertia: reelCalc.chain.refl_inert
						});
					}

					// Map total values
					if (reelCalc.total && inputData.reelDrive.reel.totalReflInertia) {
						if (reelCalc.total.total_refl_inert_empty !== undefined) {
							inputData.reelDrive.reel.totalReflInertia.empty = reelCalc.total.total_refl_inert_empty;
						}
						if (reelCalc.total.total_refl_inert_full !== undefined) {
							inputData.reelDrive.reel.totalReflInertia.full = reelCalc.total.total_refl_inert_full;
						}
					}

					// Map motor data
					if (reelCalc.motor && inputData.reelDrive.reel.motor) {
						Object.assign(inputData.reelDrive.reel.motor, {
							hp: reelCalc.motor.hp,
							inertia: reelCalc.motor.inertia,
							rpm: {
								base: reelCalc.motor.base_rpm,
								full: reelCalc.motor.rpm_full
							}
						});
					}

					// Map friction data
					if (reelCalc.friction && inputData.reelDrive.reel.friction) {
						Object.assign(inputData.reelDrive.reel.friction, {
							rBrgMand: reelCalc.friction.r_brg_mand,
							fBrgMand: reelCalc.friction.f_brg_mand,
							rBrgCoil: reelCalc.friction.r_brg_coil,
							fBrgCoil: reelCalc.friction.f_brg_coil,
							totalEmpty: reelCalc.friction.total_empty,
							totalFull: reelCalc.friction.total_full
						});
					}

					// Map speed and acceleration data
					if (reelCalc.speed && inputData.reelDrive.reel) {
						if (reelCalc.speed.speed !== undefined) inputData.reelDrive.reel.speed = reelCalc.speed.speed;
						if (reelCalc.speed.accel_rate !== undefined) inputData.reelDrive.reel.accelerationRate = reelCalc.speed.accel_rate;
						if (reelCalc.speed.accel_time !== undefined) inputData.reelDrive.reel.accelerationTime = reelCalc.speed.accel_time;
					}

					// Map other calculated fields from reel_drive
					if (reelCalc.total?.ratio !== undefined) inputData.reelDrive.reel.ratio = reelCalc.total.ratio;
					if (reelCalc.speed?.speed !== undefined) inputData.reelDrive.reel.speed = reelCalc.speed.speed;
					if (reelCalc.speed?.accel_rate !== undefined) inputData.reelDrive.reel.accelerationRate = reelCalc.speed.accel_rate;
					if (reelCalc.speed?.accel_time !== undefined) inputData.reelDrive.reel.accelerationTime = reelCalc.speed.accel_time;

					// Map torque data
					if (reelCalc.torque && inputData.reelDrive.reel.torque) {
						if (reelCalc.torque.empty !== undefined && inputData.reelDrive.reel.torque.empty) {
							inputData.reelDrive.reel.torque.empty.torque = reelCalc.torque.empty;
						}
						if (reelCalc.torque.full !== undefined && inputData.reelDrive.reel.torque.full) {
							inputData.reelDrive.reel.torque.full.torque = reelCalc.torque.full;
						}
						if (reelCalc.hp_req?.empty !== undefined && inputData.reelDrive.reel.torque.empty) {
							inputData.reelDrive.reel.torque.empty.horsepowerRequired = reelCalc.hp_req.empty;
							inputData.reelDrive.reel.torque.empty.horsepowerCheck = reelCalc.hp_req.status_empty;
						}
						if (reelCalc.hp_req?.full !== undefined && inputData.reelDrive.reel.torque.full) {
							inputData.reelDrive.reel.torque.full.horsepowerRequired = reelCalc.hp_req.full;
							inputData.reelDrive.reel.torque.full.horsepowerCheck = reelCalc.hp_req.status_full;
						}
					}
				}

				// Map coil data
				if (reelCalc.coil && inputData.reelDrive.coil) {
					Object.assign(inputData.reelDrive.coil, {
						density: reelCalc.coil.density,
						width: reelCalc.coil.width,
						weight: reelCalc.coil.weight,
						inertia: reelCalc.coil.inertia,
						reflInertia: reelCalc.coil.refl_inert
					});
				}

				// Also update common.equipment.reel if applicable
				if (reelCalc.reel && inputData.common?.equipment?.reel) {
					if (reelCalc.reel.max_width !== undefined) {
						inputData.common.equipment.reel.width = reelCalc.reel.max_width;
					}
					if (reelCalc.motor?.hp !== undefined) {
						inputData.common.equipment.reel.horsepower = reelCalc.motor.hp;
					}
					if (reelCalc.backplate?.diameter !== undefined && inputData.common.equipment.reel.backplate) {
						inputData.common.equipment.reel.backplate.diameter = reelCalc.backplate.diameter;
					}
				}
			}

			// 5. Straightener Utility calculations ‚Üí strUtility section
			if (calculatedResults.str_utility && inputData.strUtility && typeof calculatedResults.str_utility === 'object') {
				const strCalc = calculatedResults.str_utility;

				// Map according to StrUtilityData interface
				if (inputData.strUtility.straightener) {
					if (strCalc.actual_coil_weight !== undefined) {
						inputData.strUtility.straightener.actualCoilWeight = strCalc.actual_coil_weight;
					}
					if (strCalc.coil_od !== undefined) {
						inputData.strUtility.straightener.coilOD = strCalc.coil_od;
					}
					if (strCalc.jack_force_available !== undefined) {
						inputData.strUtility.straightener.jackForceAvailable = strCalc.jack_force_available;
					}
					if (strCalc.max_roll_depth !== undefined) {
						inputData.strUtility.straightener.maxRollDepth = strCalc.max_roll_depth;
					}
					if (strCalc.modulus !== undefined) {
						inputData.strUtility.straightener.modulus = strCalc.modulus;
					}
					if (strCalc.center_dist !== undefined) {
						inputData.strUtility.straightener.centerDistance = strCalc.center_dist;
					}
					if (strCalc.required_force !== undefined && inputData.strUtility.straightener.required) {
						inputData.strUtility.straightener.required.force = strCalc.required_force;
					}
					if (strCalc.horsepower_required !== undefined && inputData.strUtility.straightener.required) {
						inputData.strUtility.straightener.required.horsepower = strCalc.horsepower_required;
					}
					if (strCalc.horsepower_check !== undefined && inputData.strUtility.straightener.required) {
						inputData.strUtility.straightener.required.horsepowerCheck = strCalc.horsepower_check;
					}
					if (strCalc.feed_rate_check !== undefined && inputData.strUtility.straightener.required) {
						inputData.strUtility.straightener.required.feedRateCheck = strCalc.feed_rate_check;
					}
					if (strCalc.str_roll_check !== undefined && inputData.strUtility.straightener.required) {
						inputData.strUtility.straightener.required.strRollCheck = strCalc.str_roll_check;
					}
					if (strCalc.pinch_roll_check !== undefined && inputData.strUtility.straightener.required) {
						inputData.strUtility.straightener.required.pinchRollCheck = strCalc.pinch_roll_check;
					}

					// Map torque data
					if (inputData.strUtility.straightener.torque) {
						if (strCalc.str_torque !== undefined) {
							inputData.strUtility.straightener.torque.straightener = strCalc.str_torque;
						}
						if (strCalc.acceleration_torque !== undefined) {
							inputData.strUtility.straightener.torque.acceleration = strCalc.acceleration_torque;
						}
						if (strCalc.brake_torque !== undefined) {
							inputData.strUtility.straightener.torque.brake = strCalc.brake_torque;
						}
					}

					// Map rolls data
					if (inputData.strUtility.straightener.rolls) {
						if (strCalc.str_roll_dia !== undefined && inputData.strUtility.straightener.rolls.straightener) {
							inputData.strUtility.straightener.rolls.straightener.diameter = strCalc.str_roll_dia;
						}
						if (strCalc.str_roll_rated_torque !== undefined && inputData.strUtility.straightener.rolls.straightener) {
							inputData.strUtility.straightener.rolls.straightener.ratedTorque = strCalc.str_roll_rated_torque;
						}
						if (strCalc.str_roll_req_torque !== undefined && inputData.strUtility.straightener.rolls.straightener) {
							inputData.strUtility.straightener.rolls.straightener.requiredGearTorque = strCalc.str_roll_req_torque;
						}
						if (strCalc.pinch_roll_dia !== undefined && inputData.strUtility.straightener.rolls.pinch) {
							inputData.strUtility.straightener.rolls.pinch.diameter = strCalc.pinch_roll_dia;
						}
						if (strCalc.pinch_roll_rated_torque !== undefined && inputData.strUtility.straightener.rolls.pinch) {
							inputData.strUtility.straightener.rolls.pinch.ratedTorque = strCalc.pinch_roll_rated_torque;
						}
						if (strCalc.pinch_roll_req_torque !== undefined && inputData.strUtility.straightener.rolls.pinch) {
							inputData.strUtility.straightener.rolls.pinch.requiredGearTorque = strCalc.pinch_roll_req_torque;
						}
					}

					// Map gear data including teeth and DP values
					if (inputData.strUtility.straightener.gear) {

						if (strCalc.cont_angle !== undefined) {
							inputData.strUtility.straightener.gear.contAngle = strCalc.cont_angle;
						}
						if (strCalc.face_width !== undefined) {
							inputData.strUtility.straightener.gear.faceWidth = strCalc.face_width;
						}

						// Map teeth and DP values to the gear section
						if (strCalc.str_roll_teeth !== undefined && inputData.strUtility.straightener.gear.straightenerRoll) {
							inputData.strUtility.straightener.gear.straightenerRoll.numberOfTeeth = strCalc.str_roll_teeth;
						}
						if (strCalc.str_roll_dp !== undefined && inputData.strUtility.straightener.gear.straightenerRoll) {
							inputData.strUtility.straightener.gear.straightenerRoll.dp = strCalc.str_roll_dp;
						}
						if (strCalc.pinch_roll_teeth !== undefined && inputData.strUtility.straightener.gear.pinchRoll) {
							inputData.strUtility.straightener.gear.pinchRoll.numberOfTeeth = strCalc.pinch_roll_teeth;
						}
						if (strCalc.pinch_roll_dp !== undefined && inputData.strUtility.straightener.gear.pinchRoll) {
							inputData.strUtility.straightener.gear.pinchRoll.dp = strCalc.pinch_roll_dp;
						}
					}

				}
			}

			// 6. Roll Straightener Backbend calculations ‚Üí rollStrBackbend section
			if (calculatedResults.roll_str_backbend && inputData.rollStrBackbend && typeof calculatedResults.roll_str_backbend === 'object') {
				const rollCalc = calculatedResults.roll_str_backbend;

				// Map according to RollStrBackbendData interface
				if (rollCalc.rollConfiguration !== undefined) {
					inputData.rollStrBackbend.rollConfiguration = rollCalc.rollConfiguration;
				}

				// Map straightener data
				if (inputData.rollStrBackbend.straightener) {
					if (rollCalc.roll_diameter !== undefined && inputData.common?.equipment?.straightener) {
						inputData.common.equipment.straightener.rollDiameter = rollCalc.roll_diameter;
					}
					if (rollCalc.center_distance !== undefined) {
						inputData.rollStrBackbend.straightener.centerDistance = rollCalc.center_distance;
					}
					if (rollCalc.jack_force_available !== undefined) {
						inputData.rollStrBackbend.straightener.jackForceAvailable = rollCalc.jack_force_available;
					}
					if (rollCalc.max_roll_depth_without_material !== undefined) {
						inputData.strUtility.straightener.maxRollDepth = rollCalc.max_roll_depth_without_material;
					}
					if (rollCalc.max_roll_depth_with_material !== undefined) {
						inputData.rollStrBackbend.straightener.rolls.depth.withMaterial = rollCalc.max_roll_depth_with_material;
					}
				}

				if (inputData.rollStrBackbend.straightener?.rolls?.backbend) {
					// Map radius calculations
					if (inputData.rollStrBackbend.straightener.rolls.backbend.radius) {
						if (rollCalc.radius_off_coil !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.radius.comingOffCoil = rollCalc.radius_off_coil;
						}
						if (rollCalc.radius_off_coil_after_springback !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.radius.offCoilAfterSpringback = rollCalc.radius_off_coil_after_springback;
						}
						if (rollCalc.one_radius_off_coil !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.radius.oneOffCoil = rollCalc.one_radius_off_coil;
						}
						if (rollCalc.curve_at_yield !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.radius.curveAtYield = rollCalc.curve_at_yield;
						}
						if (rollCalc.radius_at_yield !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.radius.radiusAtYield = rollCalc.radius_at_yield;
						}
						if (rollCalc.bending_moment_to_yield !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.radius.bendingMomentToYield = rollCalc.bending_moment_to_yield;
						}
					}

					// Map roller calculations
					if (inputData.rollStrBackbend.straightener.rolls.backbend.rollers) {
						if (rollCalc.roller_depth_required !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.depthRequired = rollCalc.roller_depth_required;
						}
						if (rollCalc.roller_depth_required_check !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.depthRequiredCheck = rollCalc.roller_depth_required_check;
						}
						if (rollCalc.roller_force_required !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.forceRequired = rollCalc.roller_force_required;
						}
						if (rollCalc.roller_force_required_check !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.forceRequiredCheck = rollCalc.roller_force_required_check;
						}
						if (rollCalc.percent_yield_check !== undefined) {
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.percentYieldCheck = rollCalc.percent_yield_check;
						}

						// Map individual roll data
						if (rollCalc.first_up && inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first) {
							// Map first roller height
							if (rollCalc.first_up.roll_height_first_up !== undefined) {
								inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first.height = rollCalc.first_up.roll_height_first_up;
							}
							// Map first roller force required
							if (rollCalc.first_up.force_required_first_up !== undefined) {
								inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first.forceRequired = rollCalc.first_up.force_required_first_up;
							}
							// Map first roller yield strains at surface
							if (rollCalc.first_up.number_of_yield_strains_first_up !== undefined) {
								inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first.numberOfYieldStrainsAtSurface = rollCalc.first_up.number_of_yield_strains_first_up;
							}
							// Map first roller up direction data
							if (inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first.up) {
								Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first.up, {
									resultingRadius: rollCalc.first_up.res_rad_first_up,
									curvatureDifference: rollCalc.first_up.r_ri_first_up,
									bendingMoment: rollCalc.first_up.mb_first_up,
									bendingMomentRatio: rollCalc.first_up.mb_my_first_up,
									springback: rollCalc.first_up.springback_first_up,
									percentOfThicknessYielded: rollCalc.first_up.percent_yield_first_up,
									radiusAfterSpringback: rollCalc.first_up.radius_after_springback_first_up
								});
							}
						}

						// Map first roller down direction data
						if (rollCalc.first_down && inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first?.down) {
							Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.first.down, {
								resultingRadius: rollCalc.first_down.res_rad_first_down,
								curvatureDifference: rollCalc.first_down.r_ri_first_down,
								bendingMoment: rollCalc.first_down.mb_first_down,
								bendingMomentRatio: rollCalc.first_down.mb_my_first_down,
								springback: rollCalc.first_down.springback_first_down,
								percentOfThicknessYielded: rollCalc.first_down.percent_yield_first_down,
								radiusAfterSpringback: rollCalc.first_down.radius_after_springback_first_down
							});
						}

						// Map middle roller data dynamically
						// Handle single middle roller (for 5-roll configurations)
						if (rollCalc.mid_up_1 && !rollCalc.mid_up_2 && !rollCalc.mid_up_3) {
							// Single middle roller - map directly to middle property
							if (inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle) {
								// Map middle roller height
								if (rollCalc.mid_up_1.roll_height_mid_up !== undefined) {
									inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.height = rollCalc.mid_up_1.roll_height_mid_up;
								}
								// Map middle roller force required
								if (rollCalc.mid_up_1.force_required_mid_up !== undefined) {
									inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.forceRequired = rollCalc.mid_up_1.force_required_mid_up;
								}
								// Map middle roller yield strains at surface
								if (rollCalc.mid_up_1.number_of_yield_strains_mid_up !== undefined) {
									inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.numberOfYieldStrainsAtSurface = rollCalc.mid_up_1.number_of_yield_strains_mid_up;
								}
								// Map middle roller up direction data
								if (inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.up) {
									Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.up, {
										resultingRadius: rollCalc.mid_up_1.res_rad_mid_up,
										curvatureDifference: rollCalc.mid_up_1.r_ri_mid_up,
										bendingMoment: rollCalc.mid_up_1.mb_mid_up,
										bendingMomentRatio: rollCalc.mid_up_1.mb_my_mid_up,
										springback: rollCalc.mid_up_1.springback_mid_up,
										percentOfThicknessYielded: rollCalc.mid_up_1.percent_yield_mid_up,
										radiusAfterSpringback: rollCalc.mid_up_1.radius_after_springback_mid_up
									});
								}
								// Map middle roller down direction data
								if (rollCalc.mid_down_1 && inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.down) {
									Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle.down, {
										resultingRadius: rollCalc.mid_down_1.res_rad_mid_down,
										curvatureDifference: rollCalc.mid_down_1.r_ri_mid_down,
										bendingMoment: rollCalc.mid_down_1.mb_mid_down,
										bendingMomentRatio: rollCalc.mid_down_1.mb_my_mid_down,
										springback: rollCalc.mid_down_1.springback_mid_down,
										percentOfThicknessYielded: rollCalc.mid_down_1.percent_yield_mid_down,
										radiusAfterSpringback: rollCalc.mid_down_1.radius_after_springback_mid_down
									});
								}
							}
						} else {
							// Multiple middle rollers - map to indexed structure
							for (let i = 1; i <= 3; i++) {
								const midUpKey = `mid_up_${i}`;
								const midDownKey = `mid_down_${i}`;

								if (rollCalc[midUpKey] && inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle) {
									// Ensure the indexed structure exists
									if (!inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i]) {
										inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i] = {
											height: 0,
											forceRequired: 0,
											forceRequiredCheck: '',
											numberOfYieldStrainsAtSurface: 0,
											up: {},
											down: {}
										};
									}

									// Map middle roller height
									if (rollCalc[midUpKey].roll_height_mid_up !== undefined) {
										inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].height = rollCalc[midUpKey].roll_height_mid_up;
									}
									// Map middle roller force required
									if (rollCalc[midUpKey].force_required_mid_up !== undefined) {
										inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].forceRequired = rollCalc[midUpKey].force_required_mid_up;
									}
									// Map middle roller yield strains at surface
									if (rollCalc[midUpKey].number_of_yield_strains_mid_up !== undefined) {
										inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].numberOfYieldStrainsAtSurface = rollCalc[midUpKey].number_of_yield_strains_mid_up;
									}
									// Map middle roller up direction data
									if (inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].up) {
										Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].up, {
											resultingRadius: rollCalc[midUpKey].res_rad_mid_up,
											curvatureDifference: rollCalc[midUpKey].r_ri_mid_up,
											bendingMoment: rollCalc[midUpKey].mb_mid_up,
											bendingMomentRatio: rollCalc[midUpKey].mb_my_mid_up,
											springback: rollCalc[midUpKey].springback_mid_up,
											percentOfThicknessYielded: rollCalc[midUpKey].percent_yield_mid_up,
											radiusAfterSpringback: rollCalc[midUpKey].radius_after_springback_mid_up
										});
									}
									// Map middle roller down direction data
									if (rollCalc[midDownKey] && inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].down) {
										Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.middle[i].down, {
											resultingRadius: rollCalc[midDownKey].res_rad_mid_down,
											curvatureDifference: rollCalc[midDownKey].r_ri_mid_down,
											bendingMoment: rollCalc[midDownKey].mb_mid_down,
											bendingMomentRatio: rollCalc[midDownKey].mb_my_mid_down,
											springback: rollCalc[midDownKey].springback_mid_down,
											percentOfThicknessYielded: rollCalc[midDownKey].percent_yield_mid_down,
											radiusAfterSpringback: rollCalc[midDownKey].radius_after_springback_mid_down
										});
									}
								}
							}
						}

						if (rollCalc.last && inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last) {
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last.height = rollCalc.last.roll_height_last;
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last.forceRequired = rollCalc.last.force_required_last;
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last.forceRequiredCheck = rollCalc.last.force_required_check_last;
							inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last.numberOfYieldStrainsAtSurface = rollCalc.last.number_of_yield_strains_last;

							if (inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last.up) {
								Object.assign(inputData.rollStrBackbend.straightener.rolls.backbend.rollers.last.up, {
									resultingRadius: rollCalc.last.res_rad_last,
									curvatureDifference: rollCalc.last.r_ri_last,
									bendingMoment: rollCalc.last.mb_last,
									bendingMomentRatio: rollCalc.last.mb_my_last,
									springback: rollCalc.last.springback_last,
									percentOfThicknessYielded: rollCalc.last.percent_yield_last,
									radiusAfterSpringback: rollCalc.last.radius_after_springback_last
								});
							}
						}
					}
				}
			}

			// 7. Feed calculations ‚Üí feed.feed section
			if (calculatedResults.feed && inputData.feed?.feed) {
				const feedCalc = calculatedResults.feed;
				const feedData = inputData.feed.feed;

				// Map according to FeedData interface
				if (feedCalc.ratio !== undefined) feedData.ratio = feedCalc.ratio;
				if (feedCalc.motor_inertia !== undefined) feedData.motorInertia = feedCalc.motor_inertia;
				if (feedCalc.settle_time !== undefined) feedData.settleTime = feedCalc.settle_time;
				if (feedCalc.regen !== undefined) feedData.regen = feedCalc.regen;
				if (feedCalc.refl_inertia !== undefined) feedData.reflInertia = feedCalc.refl_inertia;
				if (feedCalc.match !== undefined) feedData.match = feedCalc.match;
				if (feedCalc.match_check !== undefined) feedData.matchCheck = feedCalc.match_check;
				if (feedCalc.feed_check !== undefined) feedData.feedCheck = feedCalc.feed_check;
				if (feedCalc.max_motor_rpm !== undefined) feedData.maxMotorRPM = feedCalc.max_motor_rpm;
				if (feedCalc.max_vel !== undefined) feedData.maxVelocity = feedCalc.max_vel;
				if (feedCalc.material_in_loop !== undefined) feedData.materialInLoop = feedCalc.material_in_loop;

				// Map torque calculations
				if (feedData.torque) {
					if (feedCalc.motor_peak_torque !== undefined) feedData.torque.motorPeak = feedCalc.motor_peak_torque;
					if (feedCalc.peak_torque !== undefined) feedData.torque.peak = feedCalc.peak_torque;
					if (feedCalc.peak_torque_check !== undefined) feedData.torque.peakCheck = feedCalc.peak_torque_check;
					if (feedCalc.frictiaonal_torque !== undefined) feedData.torque.frictional = feedCalc.frictiaonal_torque;
					if (feedCalc.loop_torque !== undefined) feedData.torque.loop = feedCalc.loop_torque;
					if (feedCalc.settle_torque !== undefined) feedData.torque.settle = feedCalc.settle_torque;
					if (feedCalc.acceleration_torque !== undefined) feedData.torque.acceleration = feedCalc.acceleration_torque;
					if (feedCalc.acceleration_torque_check !== undefined) feedData.torque.accelerationCheck = feedCalc.acceleration_torque_check;

					// Map RMS torque calculations
					if (feedData.torque.rms) {
						if (feedCalc.motor_rms_torque !== undefined) feedData.torque.rms.motor = feedCalc.motor_rms_torque;
						if (feedCalc.rms_torque_fa1 !== undefined) feedData.torque.rms.feedAngle1 = feedCalc.rms_torque_fa1;
						if (feedCalc.rms_torque_fa1_check !== undefined) feedData.torque.rms.feedAngle1Check = feedCalc.rms_torque_fa1_check;
						if (feedCalc.rms_torque_fa2 !== undefined) feedData.torque.rms.feedAngle2 = feedCalc.rms_torque_fa2;
						if (feedCalc.rms_torque_fa2_check !== undefined) feedData.torque.rms.feedAngle2Check = feedCalc.rms_torque_fa2_check;
					}
				}

				// Map table values
				if (feedCalc.table_values !== undefined) feedData.tableValues = feedCalc.table_values;

				// Also update common.equipment.feed.maximumVelocity
				if (feedCalc.max_vel !== undefined && inputData.common?.equipment?.feed) {
					inputData.common.equipment.feed.maximumVelocity = feedCalc.max_vel;
				}
			}

			// 8. Shear calculations ‚Üí shear.shear section
			if (calculatedResults.shear && inputData.shear?.shear && typeof calculatedResults.shear === 'object') {
				// Map shear calculations according to ShearData interface
				const shearCalc = calculatedResults.shear;
				const shearData = inputData.shear.shear;

				// Map basic properties
				if (shearCalc.strength !== undefined) shearData.strength = shearCalc.strength;

				// Map blade calculations
				if (shearCalc.blade && shearData.blade) {
					if (shearCalc.blade.angleOfBlade !== undefined) shearData.blade.angleOfBlade = shearCalc.blade.angleOfBlade;
					if (shearCalc.blade.initialCut && shearData.blade.initialCut) {
						if (shearCalc.blade.initialCut.length !== undefined) shearData.blade.initialCut.length = shearCalc.blade.initialCut.length;
						if (shearCalc.blade.initialCut.area !== undefined) shearData.blade.initialCut.area = shearCalc.blade.initialCut.area;
					}
				}

				// Map cylinder calculations
				if (shearCalc.cylinder && shearData.cylinder) {
					if (shearCalc.cylinder.minStroke && shearData.cylinder.minStroke) {
						if (shearCalc.cylinder.minStroke.forBlade !== undefined) shearData.cylinder.minStroke.forBlade = shearCalc.cylinder.minStroke.forBlade;
						if (shearCalc.cylinder.minStroke.requiredForOpening !== undefined) shearData.cylinder.minStroke.requiredForOpening = shearCalc.cylinder.minStroke.requiredForOpening;
					}
					if (shearCalc.cylinder.actualOpeningAboveMaxMaterial !== undefined) {
						shearData.cylinder.actualOpeningAboveMaxMaterial = shearCalc.cylinder.actualOpeningAboveMaxMaterial;
					}
				}

				// Map hydraulic calculations
				if (shearCalc.hydraulic && shearData.hydraulic) {
					if (shearCalc.hydraulic.cylinder && shearData.hydraulic.cylinder) {
						if (shearCalc.hydraulic.cylinder.area !== undefined) shearData.hydraulic.cylinder.area = shearCalc.hydraulic.cylinder.area;
						if (shearCalc.hydraulic.cylinder.volume !== undefined) shearData.hydraulic.cylinder.volume = shearCalc.hydraulic.cylinder.volume;
					}
					if (shearCalc.hydraulic.fluidVelocity !== undefined) shearData.hydraulic.fluidVelocity = shearCalc.hydraulic.fluidVelocity;
				}

				// Map conclusions
				if (shearCalc.conclusions && shearData.conclusions) {
					if (shearCalc.conclusions.force && shearData.conclusions.force) {
						if (shearCalc.conclusions.force.perCylinder !== undefined) shearData.conclusions.force.perCylinder = shearCalc.conclusions.force.perCylinder;
						if (shearCalc.conclusions.force.totalApplied && shearData.conclusions.force.totalApplied) {
							if (shearCalc.conclusions.force.totalApplied.lbs !== undefined) shearData.conclusions.force.totalApplied.lbs = shearCalc.conclusions.force.totalApplied.lbs;
							if (shearCalc.conclusions.force.totalApplied.tons !== undefined) shearData.conclusions.force.totalApplied.tons = shearCalc.conclusions.force.totalApplied.tons;
						}
						if (shearCalc.conclusions.force.requiredToShear !== undefined) shearData.conclusions.force.requiredToShear = shearCalc.conclusions.force.requiredToShear;
						if (shearCalc.conclusions.force.requiredToShearCheck !== undefined) shearData.conclusions.force.requiredToShearCheck = shearCalc.conclusions.force.requiredToShearCheck;
					}
					if (shearCalc.conclusions.safetyFactor !== undefined) shearData.conclusions.safetyFactor = shearCalc.conclusions.safetyFactor;
					if (shearCalc.conclusions.perMinute && shearData.conclusions.perMinute) {
						if (shearCalc.conclusions.perMinute.gallons && shearData.conclusions.perMinute.gallons) {
							if (shearCalc.conclusions.perMinute.gallons.instantaneous !== undefined) shearData.conclusions.perMinute.gallons.instantaneous = shearCalc.conclusions.perMinute.gallons.instantaneous;
							if (shearCalc.conclusions.perMinute.gallons.averaged !== undefined) shearData.conclusions.perMinute.gallons.averaged = shearCalc.conclusions.perMinute.gallons.averaged;
						}
						if (shearCalc.conclusions.perMinute.shearStrokes !== undefined) shearData.conclusions.perMinute.shearStrokes = shearCalc.conclusions.perMinute.shearStrokes;
						if (shearCalc.conclusions.perMinute.parts !== undefined) shearData.conclusions.perMinute.parts = shearCalc.conclusions.perMinute.parts;
					}
					if (shearCalc.conclusions.perHour && shearData.conclusions.perHour) {
						if (shearCalc.conclusions.perHour.parts !== undefined) shearData.conclusions.perHour.parts = shearCalc.conclusions.perHour.parts;
					}
				}
			}

			return inputData;
		} catch (error) {
			console.error('‚ùå Failed to run Python calculations:', error);
			// Always return original data if calculations fail - NEVER lose user data
			return inputData;
		}
	}
}
