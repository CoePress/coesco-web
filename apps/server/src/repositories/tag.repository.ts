// This file was generated by generate-services.ts
import type { Tag } from "@prisma/client";
import type { Prisma } from "@prisma/client";

import type { IQueryParams } from "@/types";

import { BadRequestError } from "@/middleware/error.middleware";
import { buildQuery, prisma } from "@/utils/prisma";

import { BaseRepository } from "./_base.repository";

type TagAttributes = Omit<Tag, "id" | "createdAt" | "updatedAt">;

export class TagRepository extends BaseRepository<Tag> {
  protected model = prisma.tag;
  protected entityName = "Tag";
  protected modelName = "tag";

  protected async validate(entity: TagAttributes): Promise<void> {
    if (!entity.description)
      throw new BadRequestError("description is required");
    if (!entity.parentTable)
      throw new BadRequestError("parentTable is required");
    if (!entity.parentId)
      throw new BadRequestError("parentId is required");
    if (!entity.createdBy)
      throw new BadRequestError("createdBy is required");
  }

  async getAll(params?: IQueryParams<Tag>, tx?: Prisma.TransactionClient) {
    if (params?.filter) {
      let filterObj: any = typeof params.filter === "string"
        ? JSON.parse(params.filter)
        : params.filter;

      if (filterObj.parentIds && Array.isArray(filterObj.parentIds)) {
        const parentIds = filterObj.parentIds;
        const parentTable = filterObj.parentTable;

        const searchFields = this.getSearchFields();
        const transformedOrderBy = this.transformSort(params?.sort, params?.order);

        const queryParams = transformedOrderBy
          ? { ...params, sort: undefined, order: undefined, filter: undefined }
          : { ...params, filter: undefined };

        const { where: baseWhere, orderBy, page, take, skip, select, include } = buildQuery(
          queryParams,
          searchFields,
        );

        const columns = await (this as any).getColumns();
        const scope = await (this as any).getScope(columns);

        const finalWhere = {
          AND: [
            baseWhere ?? {},
            scope ?? {},
            {
              parentTable,
              parentId: { in: parentIds }
            }
          ]
        };

        const model = tx ? (tx as any)[this.modelName!] : this.model;

        const query: any = {
          where: finalWhere,
          orderBy: transformedOrderBy ?? orderBy,
          take,
          skip,
        };

        if (select)
          query.select = select;
        else if (include)
          query.include = include;

        const countQuery = { where: finalWhere };

        const [items, total] = await Promise.all([
          model.findMany(query),
          model.count(countQuery),
        ]);

        const totalPages = take ? Math.ceil(total / (take || 1)) : 1;

        return {
          success: true,
          data: items,
          meta: {
            page,
            limit: take,
            total,
            totalPages,
          },
        };
      }
    }

    return super.getAll(params, tx);
  }
}
