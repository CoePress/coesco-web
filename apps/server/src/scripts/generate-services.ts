import { getDMMF } from "@prisma/sdk";
import path from "path";
import fs from "fs";

async function getRelationships(models: any) {
  const modelNames = new Set(models.map((m: any) => m.name));

  let relationships: any[] = [];
  models.forEach((model: any) => {
    model.fields.forEach((field: any) => {
      if (field.name.endsWith("Id")) {
        const targetName = field.name.slice(0, -2);
        const guessedTarget = [...modelNames].find(
          (name: any) => name.toLowerCase() === targetName.toLowerCase()
        );

        if (guessedTarget) {
          const icon = field.isRequired ? "ðŸ”—" : "ðŸ§·";
          relationships.push({
            model: model.name,
            field: field.name,
            target: guessedTarget,
            icon,
          });
        }
      }
    });
  });
  return relationships;
}

async function getModels() {
  const schemaPath = path.resolve(__dirname, "../../prisma/schema.prisma");
  const schema = fs.readFileSync(schemaPath, "utf-8");
  const dmmf = await getDMMF({ datamodel: schema });

  const models = dmmf.datamodel.models;
  return models;
}

async function generateValidations(model: any) {
  const lines: string[] = [];
  model.fields.forEach((field: any) => {
    if (
      field.kind === "scalar" &&
      field.isRequired &&
      !field.isId &&
      field.name !== "createdAt" &&
      field.name !== "updatedAt"
    ) {
      lines.push(
        `if (!entity.${field.name}) throw new BadRequestError("${field.name} is required");`
      );
    }
  });
  return lines.map((line) => "\t\t" + line).join("\n");
}

async function generateServiceFiles(models: any, relationships: any) {
  const directory = path.resolve(__dirname, "../services/repo");
  fs.mkdirSync(directory, { recursive: true });

  for (const model of models) {
    const modelNameLower =
      model.name.charAt(0).toLowerCase() + model.name.slice(1);
    const serviceFile = path.resolve(directory, `${modelNameLower}.service.ts`);
    const validations = await generateValidations(model);

    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, "0");
    const timestamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    const generatedComment = `// This file was generated by generate-services.ts on ${timestamp}\n`;

    const serviceContent = `${generatedComment}import { ${model.name} } from "@prisma/client";
import { BaseService } from "./_base.service";
import { prisma } from "@/utils/prisma";
import { BadRequestError } from "@/middleware/error.middleware";

type ${model.name}Attributes = Omit<${model.name}, "id" | "createdAt" | "updatedAt">;

export class ${model.name}Service extends BaseService<${model.name}> {
	protected model = prisma.${modelNameLower};
	protected entityName = "${model.name}";
	protected modelName = "${modelNameLower}";

	protected async validate(entity: ${model.name}Attributes): Promise<void> {
${validations}
	}
}
`;

    fs.writeFileSync(serviceFile, serviceContent);
    console.log(`Wrote: ${model.name}`);

    relationships.forEach((relationship: any) => {
      if (relationship.model === model.name) {
        console.log(relationship);
      }
    });
  }
}

async function main() {
  const models = await getModels();
  const relationships = await getRelationships(models);
  await generateServiceFiles(models, relationships);
}

main();
